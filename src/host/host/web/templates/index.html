<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AeroPrint</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
  <style>
  </style>
</head>
<body>
  <div class="container">

    <!-- Starling Status Top Right -->
    <div class="starling-status-top" id="starling-status">
      Starling: {% if starling %}Connected{% else %}Disconnected{% endif %}
    </div>

    <!-- Title Banner -->
    <div class="title-banner">
      <img src="{{ url_for('static', filename='images/aeroprint_title.png') }}" alt="AeroPrint Logo">
    </div>
  <!-- Always present in DOM -->
  <div class="top-left-stop" id="emergency-stop-container" style="display: none;">
        <button id="emergency-stop" onclick="sendStopCommand()" aria-label="Emergency Stop">
          <!-- SVG Red Octagon -->
          <svg width="48" height="48" viewBox="0 0 48 48">
            <polygon points="12,4 36,4 44,12 44,36 36,44 12,44 4,36 4,12" fill="#f44336" stroke="#900" stroke-width="2"/>
            <text x="24" y="30" text-anchor="middle" font-size="18" fill="#fff" font-family="Arial" font-weight="bold">STOP</text>
          </svg>
        </button>
      </div>

    <!-- Dev Phase Preview Menu (hidden by default, toggled with Ctrl+Q) -->
  <div id="dev-phase-menu" style="display:block; position:fixed; bottom:60px; right:24px; z-index:200; background:#222; padding:8px 16px; border-radius:8px; box-shadow:0 2px 8px #00eaff;">
      <label for="dev-phase" style="color:#b0eaff; font-weight:bold;">Dev Phase Preview:</label>
      <select id="dev-phase" onchange="simulatePhase(this.value)">
        {% for phase in ["Preflight", "Scanning", "Processing", "Meshing", "Slicing", "Printing"] %}
          <option value="{{ phase }}">{{ phase }}</option>
        {% endfor %}
      </select>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
      {% for phase in ["Preflight", "Scanning", "Processing", "Meshing", "Slicing", "Printing"] %}
        <div class="status {% if phase == stage %}active{% endif %}">{{ phase }}</div>
      {% endfor %}
    </div>

    <!-- Top Row: Camera (left) & Flight Path (right) -->
    <div class="data-row">

      <!-- Camera Section -->
      <div class="camera-view">
        <h3>Starling Camera View</h3>
        <div class="camera-box"><img src="http://192.168.8.191/video_raw/hires_small_color"></video></div>
        <div class="phase-description">
          <p></p>
          <button id="action-btn"
                  class="{{ 'start-btn' if command != 'START' else 'stop-btn' }}"
                  onclick="toggleAction()">
            {{ 'START' if command != 'START' else 'STOP' }}
          </button>
          <div class="progress-container"
               id="progress-container" 
               style="display: {{ 'none' if stage == 'Preflight' else 'flex' }};">
               <div id="progress-bar" class="progress-bar"></div>
          </div>
        </div>
      </div>

      <!-- Flight Path Section -->
      <div class="flight-path">
        <h3>Flight Visualization</h3>
        <div class="path-box" style="position:relative;">
          <div id="pointcloud-viewer" style="width:100%; height: 380px; display:none; position:absolute; top:0; left:0; background:#111;"></div>
          <div id="mesh-viewer" style="width:100%; height: 380px; display:none; position:absolute; top:0; left:0; background:#111;"></div>
          <div id="slicing-viewer" style="width:100%; height: 380px; display:none; position:absolute; top:0; left:0; pointer-events:none;"></div>
          <img id="printer-gif"
               src="{{ url_for('static', filename='images/3d_printer.gif') }}"
               alt="3D Printer Animation"
               style="display:none; width:100%; height:100%; max-width:none; max-height:none; position:absolute; top:0; left:0; z-index:30; background:#111;">
          <iframe src="/widgets/flight_config" title="Helix Path Visualizer" scrolling="no" aria-placeholder="Helix Path Visualizer"></iframe>
          <!-- Download Slicing Button: Only visible in Slicing phase -->
          <button id="download-slicing-btn"
                  onclick="window.location='/download_slicing'"
                  style="margin: 12px 0; display: none; position: absolute; top: 12px; left: 12px; z-index: 20;">
            Download Slices
          </button>
          <!-- Download Mesh Button: Only visible in Meshing phase -->
          <button id="download-mesh-btn"
                  onclick="window.location='/download_mesh'"
                  style="margin: 12px 0; display: none; position: absolute; top: 12px; left: 160px; z-index: 20;">
            Download Mesh
          </button>
        </div>

        <!-- Place the download button here -->
        <button id="download-pointcloud-btn"
                onclick="window.location='/download_pointcloud'"
                style="margin: 12px 0; display: none;">
          Download Point Cloud
        </button>

        <!-- Print Size Selector -->
        <div class="size-selector" id="size-selector">
          <button id="btn-SM" class="size-btn" onclick="selectSize('SM')">SM</button>
          <button id="btn-MED" class="size-btn" onclick="selectSize('MED')">MED</button>
          <button id="btn-LG" class="size-btn" onclick="selectSize('LG')">LG</button>
        </div>
      </div>

    </div>

    <!-- Flight Time Status -->
    <div id="flight_time_status" style="width: 100%; background: #eee; border-radius: 8px; overflow: hidden; margin: 12px 0;">
      <div id="flight_time_progress" style="width: 0%; height: 12px; background: #4caf50;"></div>
    </div>
    <span id="flight_time"></span>

  </div>

  <!-- Dynamic Command Logic -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    const socket = io();
    let selectedSize = "{{ selected_size }}";  // store size for use during START
    let devProgressInterval = null;
  let pcRefreshInterval = null;
    const connection_indicator = document.getElementById('starling-status');

    // updatePhaseDescription('Preflight');

    socket.on('connect', data => {
      console.log("Connected to server.");
      updatePhaseDescription("Preflight");
    });

    socket.on('update_phase', data => {
      phase = data.phase;
      simulatePhase(phase);
    });

    socket.on('heartbeat', data => {
    if (data.ok) {
      connection_indicator.textContent = "Starling: Connected";
      // connection_indicator.style.color = "#4CAF50"; // Green
    } else {
      connection_indicator.textContent = "Starling: Disconnected";
      // connection_indicator.style.color = "#f44336"; // Red
    }
  });

    function toggleAction() {
      const btn = document.getElementById('action-btn');
      const isStart = btn.classList.contains('start-btn');

      if (isStart) {
        // Going from START to STOP
        btn.textContent = "STOP";
        btn.classList.remove("start-btn");
        btn.classList.add("stop-btn");
        socket.emit('send_command', {
          command: "START",
          size: selectedSize
        });
        socket.emit('start_flight')
      } else {
        // Going from STOP to START
        socket.emit('land_flight');
        btn.textContent = "START";
        btn.classList.remove("stop-btn");
        btn.classList.add("start-btn");
        socket.emit('send_command', {
          command: "STOP",
          size: selectedSize
        });
      }
    }

    function selectSize(size) {
      selectedSize = size;
      // Update button highlighting
      ["SM", "MED", "LG"].forEach(s => {
        const btn = document.getElementById('btn-' + s);
        
        btn.classList.remove("active");
      });
      document.getElementById('btn-' + size).classList.add("active");
      console.log("Selected size:", selectedSize);
      socket.emit('select_size', { size: selectedSize });
      // Do NOT emit any command here!
    }

    // Update your simulatePhase function to include the printing GIF logic
function simulatePhase(phase) {
    // Update status bar visuals
    document.querySelectorAll('.status-bar .status').forEach(elem => {
        elem.classList.remove('active');
        if (elem.textContent.trim() === phase) {
            elem.classList.add('active', 'slide-in');
            setTimeout(() => elem.classList.remove('slide-in'), 600);
        }
    });

    updatePhaseDescription(phase);

    // Progress bar and button logic
    const progressContainer = document.getElementById("progress-container");
    const progressBar = document.getElementById("progress-bar");
    const actionBtn = document.getElementById("action-btn");

    if (phase === "Preflight") {
        actionBtn.style.display = "inline-block";
        progressContainer.style.display = "none";
        progressBar.style.width = "0%";
    } else {
        actionBtn.style.display = "none";
        progressContainer.style.display = "flex";
    }

    const pcViewer = document.getElementById('pointcloud-viewer');
    const meshViewer = document.getElementById('mesh-viewer');
    const slicingViewer = document.getElementById('slicing-viewer');
    const pathIframe = document.querySelector('.path-box iframe');
    const printerGif = document.getElementById('printer-gif'); // Add this line

    // Hide everything first
    if (pcViewer) pcViewer.style.display = "none";
    if (meshViewer) meshViewer.style.display = "none";
    if (slicingViewer) slicingViewer.style.display = "none";
    if (printerGif) printerGif.style.display = "none"; // Add this line
    if (pathIframe) pathIframe.style.visibility = "visible";

    // Show appropriate viewer based on phase
    if (phase === "Processing") {
        if (pcViewer) {
            pcViewer.style.display = "block";
            fetchAndShowCombinedPointCloud();
        }
        if (meshViewer) {
            meshViewer.style.display = "none";
            meshViewer.innerHTML = "";
        }
        if (slicingViewer) slicingViewer.style.display = "none";
        if (pathIframe) pathIframe.style.visibility = "visible";
    } else if (phase === "Meshing") {
        if (pcViewer) {
            pcViewer.style.display = "none";
            pcViewer.innerHTML = "";
        }
        if (meshViewer) {
            meshViewer.style.display = "block";
            fetchAndShowFullPointCloud();
        }
        if (slicingViewer) slicingViewer.style.display = "none";
        if (pathIframe) pathIframe.style.visibility = "hidden";
    } else if (phase === "Slicing") {
        if (pcViewer) pcViewer.style.display = "none";
        if (meshViewer) meshViewer.style.display = "none"; 
        if (slicingViewer){
            slicingViewer.style.display = "block";
            showSlicingPointCloud();
        }
        if (pathIframe) pathIframe.style.visibility = "hidden";
    } else if (phase === "Printing") {
        // ADD THIS BLOCK - Show printing GIF and hide everything else
        if (printerGif) printerGif.style.display = "block";
        if (pcViewer) pcViewer.style.display = "none";
        if (meshViewer) meshViewer.style.display = "none";
        if (slicingViewer) slicingViewer.style.display = "none";
        if (pathIframe) pathIframe.style.visibility = "hidden";
    } else {
        // Default case - show flight path
        if (pathIframe) pathIframe.style.visibility = "visible";
    }

    // Show/hide download buttons based on phase
    const downloadBtn = document.getElementById('download-pointcloud-btn');
    if (phase === "Processing") {
        if (downloadBtn) downloadBtn.style.display = "inline-block";
    } else {
        if (downloadBtn) downloadBtn.style.display = "none";
    }

    const downloadMeshBtn = document.getElementById('download-mesh-btn');
    if (phase === "Meshing") {
        if (downloadMeshBtn) downloadMeshBtn.style.display = "inline-block";
    } else {
        if (downloadMeshBtn) downloadMeshBtn.style.display = "none";
    }

    const downloadSlicingBtn = document.getElementById('download-slicing-btn');
    if (phase === "Slicing") {
        if (downloadSlicingBtn) downloadSlicingBtn.style.display = "inline-block";
    } else {
        if (downloadSlicingBtn) downloadSlicingBtn.style.display = "none";
    }

    const sizeSelector = document.getElementById('size-selector');
    if (phase === "Preflight") {
        if (sizeSelector) sizeSelector.style.display = "flex";
    } else {
        if (sizeSelector) sizeSelector.style.display = "none";
    }
  // Ensure stop-sign visibility follows phase during dev preview
  updatePhaseUI(phase);
}
    function updatePhaseDescription(phase) {
      const text = phaseDescriptions[phase] || "";
      const descDiv = document.querySelector('.phase-description');
      if (!descDiv) return;
      let p = descDiv.querySelector('p');
      if (!p) {
        p = document.createElement('p');
        descDiv.prepend(p);
      }
      // Set instantly (no typewriter)
      p.textContent = text;
    }

    function updatePhaseUI(phase) {
      const actionBtn = document.getElementById('action-btn');
      const progressContainer = document.querySelector('.progress-container');
      const stopContainer = document.getElementById('emergency-stop-container');

      const showStopFor = ["Scanning", "Processing", "Meshing", "Slicing"]; // show only in these phases

      if (phase === "Preflight") {
        if (actionBtn) actionBtn.style.display = "inline-block";
        if (progressContainer) progressContainer.style.display = "none";
      } else {
        if (actionBtn) actionBtn.style.display = "none";
        if (progressContainer) progressContainer.style.display = "block";
      }

      if (stopContainer) {
        stopContainer.style.display = showStopFor.includes(phase) ? "block" : "none";
      }
    }

    socket.on('command_response', data => {
      console.log("Server response:", data);
    });

    socket.on('status_update', function(data) {
      const allStatuses = document.querySelectorAll('.status-bar .status');
      allStatuses.forEach(div => {
        if (div.textContent.trim() === data.phase) {
          div.classList.add('active', 'slide-in');
          setTimeout(() => div.classList.remove('slide-in'), 600);
        } else {
          div.classList.remove('active');
        }
      });
      updatePhaseDescription(data.phase);
      updatePhaseUI(data.phase);

      // Simulate progress bar for non-Preflight phases
      if (devProgressInterval) clearInterval(devProgressInterval);
      const progressBar = document.getElementById('progress-bar');
      if (data.phase === "Preflight") {
        if (progressBar) progressBar.style.width = "0%";
      } else {
        let progress = 0;
        if (progressBar) {
          progressBar.style.width = "0%";
          devProgressInterval = setInterval(() => {
            progress = Math.min(progress + 5, 100);
            progressBar.style.width = progress + "%";
            if (progress === 100) clearInterval(devProgressInterval);
          }, 400);
        }
      }

      const pcViewer = document.getElementById('pointcloud-viewer');
      const meshViewer = document.getElementById('mesh-viewer');
      const slicingViewer = document.getElementById('slicing-viewer');
      const pathIframe = document.querySelector('.path-box iframe');
      // Clear any previous periodic refresh
      if (pcRefreshInterval) { clearInterval(pcRefreshInterval); pcRefreshInterval = null; }

    if (data.phase === "Scanning") {
        if (pcViewer) {
          pcViewer.style.display = "block";
      fetchAndShowFullPointCloud(); // render whatever exists so far
          pcRefreshInterval = setInterval(() => fetchAndShowFullPointCloud(), 3000);
        }
        if (meshViewer) { meshViewer.style.display = "none"; meshViewer.innerHTML = ""; }
        if (slicingViewer) slicingViewer.style.display = "none";
        if (pathIframe) pathIframe.style.visibility = "visible";
      } else if (data.phase === "Processing") {
        if (pcViewer) {
          pcViewer.style.display = "block";
      fetchAndShowCombinedPointCloud(0.02); // ~2% of points
        }
        if (meshViewer) {
          meshViewer.style.display = "none";
          meshViewer.innerHTML = ""; // <-- Remove any old canvas!
        }
        if (slicingViewer) slicingViewer.style.display = "none";
        if (pathIframe) pathIframe.style.visibility = "visible";
    } else if (data.phase === "Meshing") {
        if (pcViewer) {
          pcViewer.style.display = "none";
          pcViewer.innerHTML = ""; // <-- Remove any old canvas!
        }
        if (meshViewer) {
          meshViewer.style.display = "block";
      fetchAndShowFullPointCloud(0.8); // ~80% of points
        }
        if (slicingViewer) slicingViewer.style.display = "none";
        if (pathIframe) pathIframe.style.visibility = "hidden";
      } else if (data.phase === "Slicing") {
        if (pcViewer) pcViewer.style.display = "none";
        if (meshViewer) {
          meshViewer.style.display = "block";
          showMesh();
        }
        if (slicingViewer) {
          slicingViewer.style.display = "block";
          showSlicing(); // function to render slicing visualization
        }
        if (pathIframe) pathIframe.style.visibility = "hidden";
      } else if (data.phase === "Printing") {
        const printerGif = document.getElementById('printer-gif');
        if (printerGif) printerGif.style.display = "block";
        if (pcViewer) pcViewer.style.display = "none";
        if (meshViewer) meshViewer.style.display = "none";
        if (slicingViewer) slicingViewer.style.display = "none";
        if (pathIframe) pathIframe.style.visibility = "hidden";
      } else {
        if (pcViewer) pcViewer.style.display = "none";
        if (meshViewer) meshViewer.style.display = "none";
        if (slicingViewer) slicingViewer.style.display = "none";
        if (pathIframe) pathIframe.style.visibility = "visible";
      }

      // Show/hide the download button based on phase
      const downloadBtn = document.getElementById('download-pointcloud-btn');
      if (data.phase === "Processing") {
        if (downloadBtn) downloadBtn.style.display = "inline-block";
      } else {
        if (downloadBtn) downloadBtn.style.display = "none";
      }

      // Show/hide the download mesh button based on phase
      const downloadMeshBtn = document.getElementById('download-mesh-btn');
      if (data.phase === "Meshing") {
        if (downloadMeshBtn) downloadMeshBtn.style.display = "inline-block";
      } else {
        if (downloadMeshBtn) downloadMeshBtn.style.display = "none";
      }

      // Show/hide the download slicing button based on phase
      const downloadSlicingBtn = document.getElementById('download-slicing-btn');
      if (data.phase === "Slicing") {
        if (downloadSlicingBtn) downloadSlicingBtn.style.display = "inline-block";
      } else {
        if (downloadSlicingBtn) downloadSlicingBtn.style.display = "none";
      }
    });

    socket.on('progress_update', function(data) {
      const bar = document.getElementById('progress-bar');
      if (bar) bar.style.width = data.percent + '%';
    });

    socket.on('flight_time_remaining', function(data) {
      console.log("Flight time remaining data:", data);
      const flight_time_status_indicator = document.getElementById('progress-bar');
      const flight_time_label = document.getElementById('flight_time');
      const time_remaining = data.time; // seconds remaining
      const flight_time_est = window.flight_time_est || 1; // set this to your total flight time in seconds

      // Calculate percent complete
      const percent = Math.round((1 - time_remaining / flight_time_est) * 100);
      flight_time_status_indicator.style.width = `${percent}%`;
      flight_time_status_indicator.setAttribute('title', `${percent}% complete`);

      // Optional: Show time remaining
      flight_time_label.textContent = `Time left: ${Math.ceil(time_remaining)}s`;
    });

    socket.on('flight_time_estimate', function(data) {
      window.flight_time_est = data.time; // seconds
      const flight_time_label = document.getElementById('flight_time');
      flight_time_label.textContent = `Estimated Flight Time: ${Math.ceil(window.flight_time_est)}s`;
    });

    // --- Helper: robust PCD header parsing ---
    function findBytes(haystack, needle) {
      outer: for (let i = 0; i <= haystack.length - needle.length; i++) {
        for (let j = 0; j < needle.length; j++) {
          if (haystack[i + j] !== needle[j]) continue outer;
        }
        return i;
      }
      return -1;
    }

    function getPcdHeaderInfo(arrayBuffer) {
      const maxHeader = Math.min(arrayBuffer.byteLength, 16384);
      const headerBytes = new Uint8Array(arrayBuffer, 0, maxHeader);
      const enc = new TextEncoder();
      const needle = enc.encode('DATA binary');
      const dataIdx = findBytes(headerBytes, needle);
      if (dataIdx === -1) {
        console.warn('PCD: DATA binary not found in header');
        return null;
      }
      // Find newline after DATA binary
      let newlineIdx = -1;
      for (let i = dataIdx; i < headerBytes.length; i++) {
        if (headerBytes[i] === 0x0A) { // '\n'
          newlineIdx = i;
          break;
        }
      }
      if (newlineIdx === -1) {
        console.warn('PCD: newline after DATA binary not found');
        return null;
      }
      const dataOffset = newlineIdx + 1; // byte offset where binary data starts

      // Decode header text up to dataOffset to get POINTS
      const headerText = new TextDecoder('utf-8').decode(headerBytes.slice(0, Math.min(dataOffset, headerBytes.length)));
      const pointsMatch = headerText.match(/POINTS\s+(\d+)/i);
      const numPoints = pointsMatch ? parseInt(pointsMatch[1]) : undefined;
      if (!numPoints || Number.isNaN(numPoints)) {
        console.warn('PCD: could not parse POINTS from header');
        return { dataOffset };
      }
      return { dataOffset, numPoints };
    }

    function sendStopCommand() {
      // Trigger safe land pathway
      socket.emit('land_flight');
    }

  // Dev menu is always visible now (Ctrl+Q toggle removed)

    const phaseDescriptions = {
      "Preflight": "ðŸ“SELECT A SIZE AND PRESS START TO BEGIN THE SCAN PROCESS. A FLIGHT PATH WILL THEN BE CALCULATED AND LOADED INTO THE DRONE.",
      "Scanning": "ðŸ“¡ STARLING IS ACTIVELY FLYING THE SET PATH AND COLLECTING 3D SURFACE DATA USING ONBOARD DEPTH SENSORS.",
      "Processing": "ðŸ§¹ CAPTURED POINT CLOUDS ARE BEING CLEANED AND ALIGNED. NOISE REDUCTION AND FILTERING ARE APPLIED FOR PRECISION GEOMETRY.",
      "Meshing": "ðŸ§  POINT CLOUD DATA IS BEING TRANSFORMED INTO A FULL 3D MESHâ€”BUILDING SURFACE TOPOLOGY FROM FLIGHT SCANS.",
      "Slicing": "âœ‚ï¸ THE MESH MODEL IS SLICED INTO PRINTABLE LAYERS. G-CODE IS GENERATED TO PREPARE FOR PRINTING.",
      "Printing": "ðŸ–¨ï¸ PRINT OPERATION IS UNDERWAY. LAYERS ARE BEING DEPOSITED IN SEQUENCE USING THE GENERATED TOOLPATH."
    };

    // Update phase description on load (no typewriter)
    document.addEventListener('DOMContentLoaded', () => {
      updatePhaseDescription("{{ stage }}");
      updatePhaseUI("{{ stage }}"); // ensure correct initial visibility for stop button
    });

    let pcViewerInitialized = false;
function initPointCloudViewer() {
  if (pcViewerInitialized) return;
  pcViewerInitialized = true;

  const container = document.getElementById('pointcloud-viewer');
  const width = container.clientWidth;
  const height = container.clientHeight;

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
  camera.position.z = 5;

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(width, height);
  container.appendChild(renderer.domElement);

  // Example: Add random points (replace with your real point cloud data)
  const geometry = new THREE.BufferGeometry();
  const numPoints = 2000;
  const positions = new Float32Array(numPoints * 3);
  for (let i = 0; i < numPoints * 3; i++) {
    positions[i] = (Math.random() - 0.5) * 10;
  }
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const material = new THREE.PointsMaterial({ color: 0x00aaff, size: 0.05 });
  const points = new THREE.Points(geometry, material);
  scene.add(points);

  function animate() {
    requestAnimationFrame(animate);
    points.rotation.y += 0.002;
    renderer.render(scene, camera);
  }
  animate();
}

let pcViewerRenderer = null;
let pcViewerAnimationId = null;
let meshViewerRenderer = null;
let meshViewerAnimationId = null;

function showPointCloud(pointsArray) {
  const container = document.getElementById('pointcloud-viewer');
  const width = container.clientWidth;
  const height = container.clientHeight;

  // Clean up previous renderer and animation
  if (pcViewerRenderer) {
    pcViewerRenderer.dispose?.();
    pcViewerRenderer.forceContextLoss?.();
    pcViewerRenderer = null;
  }
  if (pcViewerAnimationId) {
    cancelAnimationFrame(pcViewerAnimationId);
    pcViewerAnimationId = null;
  }
  container.innerHTML = "";

  // Three.js setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
  camera.position.z = 5;

  pcViewerRenderer = new THREE.WebGLRenderer({antialias:true});
  pcViewerRenderer.setSize(width, height);
  container.appendChild(pcViewerRenderer.domElement);

  // Create geometry from real data
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pointsArray), 3));
  const material = new THREE.PointsMaterial({ color: 0x00aaff, size: 0.05 });
  const points = new THREE.Points(geometry, material);
  scene.add(points);

  function animate() {
    pcViewerAnimationId = requestAnimationFrame(animate);
    points.rotation.y += 0.002;
    pcViewerRenderer.render(scene, camera);
  }
  animate();
}

function showMeshPointCloud(pointsArray) {
  const container = document.getElementById('mesh-viewer');
  const width = container.clientWidth;
  const height = container.clientHeight;

  // Clean up previous renderer and animation
  if (meshViewerRenderer) {
    meshViewerRenderer.dispose?.();
    meshViewerRenderer.forceContextLoss?.();
    meshViewerRenderer = null;
  }
  if (meshViewerAnimationId) {
    cancelAnimationFrame(meshViewerAnimationId);
    meshViewerAnimationId = null;
  }
  container.innerHTML = "";

  // Three.js setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
  camera.position.z = 5;

  meshViewerRenderer = new THREE.WebGLRenderer({antialias:true});
  meshViewerRenderer.setSize(width, height);
  container.appendChild(meshViewerRenderer.domElement);

  // Create geometry from real data
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pointsArray), 3));
  geometry.computeBoundingBox();
  if (geometry.boundingBox) {
    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
    const size = geometry.boundingBox.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    camera.position.set(center.x, center.y, center.z + maxDim * 2);
    camera.lookAt(center);
  }

  const material = new THREE.PointsMaterial({ color: 0x00aaff, size: 0.05 });
  const points = new THREE.Points(geometry, material);
  scene.add(points);

  function animate() {
    meshViewerAnimationId = requestAnimationFrame(animate);
    points.rotation.y += 0.002;
    meshViewerRenderer.render(scene, camera);
  }
  animate();
}

// Listen for point cloud data from backend
socket.on('pointcloud_data', function(data) {
  window.latestPointCloud = data.points; // Cache for dev mode
  const pcViewer = document.getElementById('pointcloud-viewer');
  if (pcViewer) {
    pcViewer.style.display = "block";
    showPointCloud(data.points);
  }
});

function showMesh() {
  const container = document.getElementById('mesh-viewer');
  const width = container.clientWidth;
  const height = container.clientHeight;

  // Clear previous
  container.innerHTML = "";

  // Three.js setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
  camera.position.z = 5;

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(width, height);
  container.appendChild(renderer.domElement);

  // Example: Add a demo mesh (replace with your real mesh)
  const geometry = new THREE.BoxGeometry(2, 2, 2);
  const material = new THREE.MeshNormalMaterial({wireframe: false});
  const mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  function animate() {
    requestAnimationFrame(animate);
    mesh.rotation.y += 0.01;
    mesh.rotation.x += 0.005;
    renderer.render(scene, camera);
  }
  animate();
}

function showSlicing() {
  const container = document.getElementById('slicing-viewer');
  const width = container.clientWidth;
  const height = container.clientHeight;

  // Clear previous
  container.innerHTML = "";

  // Three.js setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
  camera.position.z = 5;

  const renderer = new THREE.WebGLRenderer({alpha:true});
  renderer.setSize(width, height);
  container.appendChild(renderer.domElement);

  // Example: Add slicing planes (replace with your real slicing data)
  for (let i = -1; i <= 1; i += 0.2) {
    const geometry = new THREE.PlaneGeometry(2, 2);
    const material = new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide, transparent: true, opacity: 0.2});
    const plane = new THREE.Mesh(geometry, material);
    plane.position.z = i;
    scene.add(plane);
  }

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();
}

// --- Fetch and show only the combined_filtered.pcd (Processing phase) ---
function samplePointsByRatio(floatData, ratio = 1.0) {
  if (!floatData || !floatData.length || ratio >= 0.999) return floatData;
  const n = Math.floor(floatData.length / 3);
  const target = Math.max(1, Math.floor(n * Math.max(0.0, Math.min(ratio, 1.0))));
  const stride = Math.max(1, Math.floor(n / target));
  const out = new Float32Array(target * 3);
  let oi = 0;
  for (let i = 0; i < n && oi < out.length; i += stride) {
    const j = i * 3;
    out[oi++] = floatData[j];
    out[oi++] = floatData[j + 1];
    out[oi++] = floatData[j + 2];
  }
  return out.subarray(0, oi);
}

async function fetchAndShowCombinedPointCloud(ratio = 1.0) {
  const response = await fetch('/api/get_current_scan_num');
  const scanNumberObj = await response.json();
  const scanNumber = scanNumberObj.scan_num !== undefined ? scanNumberObj.scan_num : scanNumberObj;

  const assetsResponse = await fetch(`/api/list_assets/${scanNumber}/pcd`);
  const assets = await assetsResponse.json();
  const asset = assets.find(
    asset =>
      asset.type === "file" &&
      asset.name === "combined_filtered.pcd"
  );
  if (!asset) {
    // Fallback: render all available PCDs into the Processing viewer
    const pcdFiles = assets.filter(a => a.type === 'file' && a.name.endsWith('.pcd'));
    if (!pcdFiles.length) {
      console.warn("No PCD files found for scan number", scanNumber);
      return;
    }
    let allPoints = [];
    for (const f of pcdFiles) {
      try {
        const pcdResp = await fetch(f.path);
        const arrayBuffer = await pcdResp.arrayBuffer();
        const info = getPcdHeaderInfo(arrayBuffer);
        if (!info || info.dataOffset == null || !info.numPoints) {
          console.warn(`PCD header parsing failed for ${f.name}`);
          continue;
        }
        const sliced = arrayBuffer.slice(info.dataOffset);
        const floatData = new Float32Array(sliced, 0, info.numPoints * 3);
        allPoints.push(...floatData);
      } catch (e) {
        console.warn(`Failed to load ${f.name}:`, e);
      }
    }
    if (allPoints.length) {
      const sampled = samplePointsByRatio(new Float32Array(allPoints), ratio);
      showPointCloud(sampled);
      console.info(`Fallback: rendered ${pcdFiles.length} PCD files (${allPoints.length / 3} points)`);
    } else {
      console.warn("Fallback failed: no points parsed from available PCD files");
    }
    return;
  }
  const pcdResponse = await fetch(asset.path);
  const arrayBuffer = await pcdResponse.arrayBuffer();
  const info = getPcdHeaderInfo(arrayBuffer);
  if (!info || info.dataOffset == null) {
    console.warn('PCD header parsing failed for combined_filtered.pcd');
    return;
  }
  const numPoints = info.numPoints;
  const sliced = arrayBuffer.slice(info.dataOffset); // aligned buffer start
  const floatData = numPoints ? new Float32Array(sliced, 0, numPoints * 3) : new Float32Array(sliced);
  const sampled = samplePointsByRatio(floatData, ratio);
  showPointCloud(sampled); // <-- renders in pointcloud-viewer
  console.log(`Parsed ${numPoints} points from combined_filtered.pcd`);
}

// --- Fetch and show all individual PCDs (Meshing/Scanning) ---
async function fetchAndShowFullPointCloud(ratio = 1.0) {
  const response = await fetch('/api/get_current_scan_num');
  const scanNumberObj = await response.json();
  const scanNumber = scanNumberObj.scan_num !== undefined ? scanNumberObj.scan_num : scanNumberObj;

  const assetsResponse = await fetch(`/api/list_assets/${scanNumber}/pcd`);
  const assets = await assetsResponse.json();
  const pcdFiles = assets.filter(
    asset =>
      asset.type === "file" &&
      asset.name.endsWith('.pcd') &&
      asset.name !== "combined_filtered.pcd"
  );
  let allPoints = [];
  for (const asset of pcdFiles) {
    const pcdResponse = await fetch(asset.path);
    const arrayBuffer = await pcdResponse.arrayBuffer();
    const info = getPcdHeaderInfo(arrayBuffer);
    if (!info || info.dataOffset == null || !info.numPoints) {
      console.warn(`PCD header parsing failed for ${asset.name}`);
      continue;
    }
    const sliced = arrayBuffer.slice(info.dataOffset);
    const floatData = new Float32Array(sliced, 0, info.numPoints * 3);
    allPoints.push(...floatData);
    console.log(`Parsed ${info.numPoints} points from ${asset.name}`);
  }
  const sampled = samplePointsByRatio(new Float32Array(allPoints), ratio);
  showMeshPointCloud(sampled); // <-- renders in mesh-viewer
}

async function showSlicingPointCloud() {
  const container = document.getElementById('slicing-viewer');
  const width = container.clientWidth;
  const height = container.clientHeight;
  container.innerHTML = "";

  // Aggregate all PCD files for slicing view
  const response = await fetch('/api/get_current_scan_num');
  const scanNumberObj = await response.json();
  const scanNumber = scanNumberObj.scan_num !== undefined ? scanNumberObj.scan_num : scanNumberObj;

  const assetsResponse = await fetch(`/api/list_assets/${scanNumber}/pcd`);
  const assets = await assetsResponse.json();
  const pcdFiles = assets.filter(a => a.type === 'file' && a.name.endsWith('.pcd'));
  if (!pcdFiles.length) {
    console.warn("No PCD files found for slicing for scan", scanNumber);
    return;
  }
  let allPoints = [];
  for (const f of pcdFiles) {
    try {
      const pcdResp = await fetch(f.path);
      const arrayBuffer = await pcdResp.arrayBuffer();
      const info = getPcdHeaderInfo(arrayBuffer);
      if (!info || info.dataOffset == null || !info.numPoints) {
        console.warn(`PCD header parsing failed for ${f.name}`);
        continue;
      }
      const sliced = arrayBuffer.slice(info.dataOffset);
      const floatData = new Float32Array(sliced, 0, info.numPoints * 3);
      allPoints.push(...floatData);
    } catch (e) {
      console.warn(`Failed to load ${f.name}:`, e);
    }
  }

  // Three.js setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
  camera.position.z = 5;

  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setSize(width, height);
  container.appendChild(renderer.domElement);

  // Create geometry from real data
  const geometry = new THREE.BufferGeometry();
  const floatData = new Float32Array(allPoints);
  geometry.setAttribute('position', new THREE.BufferAttribute(floatData, 3));
  geometry.computeBoundingBox();
  let center = new THREE.Vector3(0,0,0);
  let size = new THREE.Vector3(1,1,1);
  if (geometry.boundingBox) {
    center = geometry.boundingBox.getCenter(new THREE.Vector3());
    size = geometry.boundingBox.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    camera.position.set(center.x, center.y, center.z + maxDim * 1.2);
    camera.lookAt(center);

    // Center the geometry so rotation is around its center
    geometry.translate(-center.x, -center.y, -center.z);
  }

  const material = new THREE.PointsMaterial({ color: 0xff8800, size: 0.05 });
  const points = new THREE.Points(geometry, material);
  scene.add(points);

  // Add animated slicing planes
  const planeGeometryXZ = new THREE.PlaneGeometry(size.x * 1.2, size.y * 1.2);
  const planeGeometryYZ = new THREE.PlaneGeometry(size.z * 1.2, size.y * 1.2);
  const planeGeometryXY = new THREE.PlaneGeometry(size.x * 1.2, size.z * 1.2);

  const planeMaterial = new THREE.MeshBasicMaterial({
    color: 0x00eaff,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.18
  });

  // Z slicing plane (XY plane, moves along Z)
  const slicingPlaneZ = new THREE.Mesh(planeGeometryXZ, planeMaterial.clone());
  scene.add(slicingPlaneZ);

  // X slicing plane (YZ plane, moves along X)
  const slicingPlaneX = new THREE.Mesh(planeGeometryYZ, planeMaterial.clone());
  slicingPlaneX.rotation.y = Math.PI / 2;
  scene.add(slicingPlaneX);

  // Y slicing plane (XZ plane, moves along Y)
  const slicingPlaneY = new THREE.Mesh(planeGeometryXY, planeMaterial.clone());
  slicingPlaneY.rotation.x = Math.PI / 2;
  scene.add(slicingPlaneY);

  // Diagonal slicing plane (moves along X and Z)
  const slicingPlaneDiag = new THREE.Mesh(planeGeometryXZ, planeMaterial.clone());
  slicingPlaneDiag.rotation.z = Math.PI / 4;
  scene.add(slicingPlaneDiag);

  let t = 0;
  function animate() {
    requestAnimationFrame(animate);

    t += 0.01;
    // Animate the slicing planes
    slicingPlaneZ.position.z = center.z + Math.sin(t) * size.z * 0.6;
    slicingPlaneX.position.x = center.x + Math.cos(t * 1.2) * size.x * 0.6;
    slicingPlaneY.position.y = center.y + Math.sin(t * 0.8) * size.y * 0.6;
    slicingPlaneDiag.position.x = center.x + Math.sin(t * 0.7) * size.x * 0.6;
    slicingPlaneDiag.position.z = center.z + Math.cos(t * 0.7) * size.z * 0.6;

    points.rotation.y += 0.002; // Rotate the point cloud

    renderer.render(scene, camera);
  }
  animate();
}

// Add this function to your index.html JavaScript section

function updatePhaseVisuals(phase) {
    // Hide all phase-specific elements first
    const printingGif = document.querySelector('.printing-gif');
    const scanningElements = document.querySelectorAll('.scanning-visual');
    const meshingElements = document.querySelectorAll('.meshing-visual');
    const slicingElements = document.querySelectorAll('.slicing-visual');
    
    // Hide all phase visuals
    if (printingGif) printingGif.style.display = 'none';
    scanningElements.forEach(el => el.style.display = 'none');
    meshingElements.forEach(el => el.style.display = 'none');
    slicingElements.forEach(el => el.style.display = 'none');
    
    // Show appropriate visual based on phase
    switch(phase) {
        case "Printing":
            if (printingGif) printingGif.style.display = 'block';
            break;
        case "Scanning":
            scanningElements.forEach(el => el.style.display = 'block');
            break;
        case "Meshing":
            meshingElements.forEach(el => el.style.display = 'block');
            break;
        case "Slicing":
            slicingElements.forEach(el => el.style.display = 'block');
            break;
        default:
            // Preflight, Takeoff, Landing - no special visuals
            break;
    }
}

// Update your existing socket listener for status updates
socket.on('status_update', function(data) {
    console.log('Status update received:', data);
    
    // Update the phase display
    const phaseElement = document.querySelector('#current-phase');
    if (phaseElement) {
        phaseElement.textContent = data.phase;
    }
    
    // Update phase-specific visuals
    updatePhaseVisuals(data.phase);
    
    // Update progress bar or other UI elements as needed
    updatePhaseProgress(data.phase);
});

// Optional: Function to update progress based on phase
function updatePhaseProgress(phase) {
    const progressBar = document.querySelector('.progress-bar');
    if (!progressBar) return;
    
    const phaseProgress = {
        "Preflight": 0,
        "Takeoff": 20,
        "Scanning": 40,
        "Landing": 60,
        "Meshing": 70,
        "Slicing": 85,
        "Printing": 100
    };
    
    const progress = phaseProgress[phase] || 0;
    progressBar.style.width = `${progress}%`;
}
  </script>
</body>
</html>