<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cylinder Visualizer</title>
    <style>
        body { 
            font-family: sans-serif; background: #222; color: #eee; 
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; height: 100vh; margin: 0; padding: 0;
        }
        #controls { 
            margin-bottom: 1em; 
            padding: 1em;
        }
        label { margin-right: 1em; }
        canvas { display: block; margin: 0 auto; background: #111; }
        #container {
            max-width: 800px;
            height: 500px;
            overflow: hidden;            
        }
        input[type="number"] {
            transform: translateX(40%);
        }
    </style>
</head>
<body>
    <div id="controls">
        <label>
            Radius:
            <input type="range" id="radius" value="2" min="0.2" step="0.2" max="3" oninput="document.getElementById('radiusValue').textContent = this.value;">
            <span id="radiusValue">2</span>
        </label>
        <label>
            Height:
            <input type="range" id="height" value="2" min="0.1" step="0.1" max="5" oninput="document.getElementById('heightValue').textContent = this.value; updateCylinder();">
            <span id="heightValue">2</span>
        </label>
        <br>
    </div>
    <div style="display: flex; flex-direction: row; align-items: flex-start;">
        <!-- Vertical slider for Starting Height -->
        <div style="display: flex; flex-direction: column; align-items: center; margin-right: 1em;">
            <input
                type="range"
                id="startHeightSlider"
                min="0"
                max="5"
                step="0.1"
                value="0"
                style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 32px; height: 500px; margin-bottom: 0.5em;"
            >
            <input
                type="number"
                id="startHeight"
                value="0"
                min="0"
                max="5"
                step="0.01"
                style="width: 60px; margin-top: 0.5em;left:0; margin: 12px;"
            >
        </div>
        <div id="container" class="visualizer"></div>
    </div>
    <div id="save-button-container" style="position: absolute; bottom: 10px; right: 10px;">
        <button id="save-button" style="padding: 10px 20px; font-size: 16px;">Save</button>
    </div>
    <!-- Notification box -->
    <div id="notification" style="display:none;position:fixed;top:30px;left:50%;transform:translateX(-50%);background:#323232;color:#fff;padding:18px 32px;border-radius:12px;box-shadow:0 2px 16px #0008;font-size:1.2em;z-index:2000;min-width:200px;text-align:center;"></div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js';
        import { io } from 'https://cdn.jsdelivr.net/npm/socket.io-client@4.7.5/dist/socket.io.esm.min.js';
        window.socket = io();
        let scene, camera, renderer, cylinderMesh, axesGroup;

        function createAxesMarkers(length = 5, step = 1) {
            const group = new THREE.Group();
            const axes = [
                { dir: [1,0,0], color: 0xffffff, label: 'X' },
                { dir: [0,1,0], color: 0x00a4ff, label: 'Z' },
                { dir: [0,0,1], color: 0xffffff, label: 'Y' }
            ];
            axes.forEach(axis => {
                const mat = new THREE.LineBasicMaterial({ color: axis.color });
                const geo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0,0,0),
                    new THREE.Vector3(axis.dir[0]*length, axis.dir[1]*length, axis.dir[2]*length)
                ]);
                group.add(new THREE.Line(geo, mat));
                for (let i = 1; i <= length; i += step) {
                    const markerGeo = new THREE.SphereGeometry(0.07, 8, 8);
                    const markerMat = new THREE.MeshBasicMaterial({ color: axis.color });
                    const marker = new THREE.Mesh(markerGeo, markerMat);
                    marker.position.set(axis.dir[0]*i, axis.dir[1]*i, axis.dir[2]*i);
                    group.add(marker);
                }
            });
            return group;
        }

        function addInputListeners() {
            // Update on any input change
            document.getElementById("radius").addEventListener("input", updateCylinder);
            document.getElementById("height").addEventListener("input", updateCylinder);

            // Sync slider and number input for startHeight
            const slider = document.getElementById("startHeightSlider");
            const number = document.getElementById("startHeight");
            slider.addEventListener("input", () => {
                number.value = slider.value;
                updateCylinder();
            });
            number.addEventListener("input", () => {
                slider.value = number.value;
                updateCylinder();
            });

            // Add listener for the Save button
            document.getElementById("save-button").addEventListener("click", () => {
                if (window.socket && window.socket.emit) {
                    const params = getCylinderParameters();
                    window.socket.emit('save_cylinder', params);
                }
            });
        }

        function getCylinderParameters() {
            return {
                radius: parseFloat(document.getElementById('radius').value),
                height: parseFloat(document.getElementById('height').value),
                startHeight: parseFloat(document.getElementById('startHeight').value)
            };
        }

        function updateCylinder() {
            const radius = parseFloat(document.getElementById('radius').value);
            const height = parseFloat(document.getElementById('height').value);
            const startHeight = parseFloat(document.getElementById('startHeight').value);

            if (cylinderMesh) scene.remove(cylinderMesh);

            // CylinderGeometry: radiusTop, radiusBottom, height, radialSegments
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 64);
            // Use MeshStandardMaterial for better lighting, set color to blue
            const material = new THREE.MeshStandardMaterial({ color: 0x2196f3, transparent: true, opacity: 0.8 });
            cylinderMesh = new THREE.Mesh(geometry, material);
            // Center the cylinder at (0, startHeight + height/2, 0)
            cylinderMesh.position.set(0, startHeight + height/2, 0);
            scene.add(cylinderMesh);
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            const width = Math.min(window.innerWidth * 0.9, 800);
            const heightPx = 500;
            camera = new THREE.PerspectiveCamera(60, width / heightPx, 0.1, 100);
            let cameraDistance = 10;
            let theta = Math.PI/4, phi = Math.PI/6;

            function updateCameraPosition() {
                camera.position.x = cameraDistance * Math.sin(theta) * Math.cos(phi);
                camera.position.y = cameraDistance * Math.sin(phi) + 2;
                camera.position.z = cameraDistance * Math.cos(theta) * Math.cos(phi);
                camera.lookAt(0, 1, 0);
            }

            camera.position.set(6, 6, 6);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, heightPx);
            renderer.setClearColor(0x888888);
            renderer.domElement.style.display = "block";
            renderer.domElement.style.margin = "0 auto";
            renderer.domElement.style.position = "relative";
            renderer.domElement.style.left = "50%";
            renderer.domElement.style.transform = "translateX(-50%)";
            document.getElementById('container').appendChild(renderer.domElement);

            // Lighting: add ambient and directional for good blue color
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const directional = new THREE.DirectionalLight(0xffffff, 0.8);
            directional.position.set(10, 10, 10);
            scene.add(directional);

            // Axes with markers
            axesGroup = createAxesMarkers(5, 1);
            scene.add(axesGroup);

            updateCylinder();

            // Simple orbit controls
            let isDragging = false, prevX, prevY;
            renderer.domElement.addEventListener('mousedown', e => {
                isDragging = true; prevX = e.clientX; prevY = e.clientY;
            });
            window.addEventListener('mousemove', e => {
                if (!isDragging) return;
                theta -= (e.clientX - prevX) * 0.01;
                phi -= (e.clientY - prevY) * 0.01;
                phi = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, phi));
                updateCameraPosition();
                prevX = e.clientX; prevY = e.clientY;
            });
            window.addEventListener('mouseup', () => { isDragging = false; });

            // --- Scroll to zoom ---
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.01;
                cameraDistance = Math.max(3, Math.min(30, cameraDistance));
                updateCameraPosition();
            }, { passive: false });

            updateCameraPosition();

            addInputListeners();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const width = Math.min(window.innerWidth * 0.9, 800);
            const heightPx = 500;
            camera.aspect = width / heightPx;
            camera.updateProjectionMatrix();
            renderer.setSize(width, heightPx);
        });

        init();
    </script>
</body>
</html>